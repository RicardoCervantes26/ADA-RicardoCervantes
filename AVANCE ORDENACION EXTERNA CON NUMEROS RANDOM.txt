import javax.swing.*;  
import java.awt.*;  
import java.awt.event.*; 
import java.io.*;
import java.util.*;

public class Class2 {

    // ==================== MÉTODO PRINCIPAL ====================
    public static void main(String[] args) {
        // Creo la ventana
        JFrame ventana = new JFrame("Ordenación Externa - Ejemplo");
        ventana.setSize(450, 250);
        ventana.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        ventana.setLayout(new FlowLayout());

        // Etiquetas
        JLabel etiquetaInfo = new JLabel("Ingrese la cantidad de números a generar:");
        JTextField campoCantidad = new JTextField(10);
        JLabel etiquetaResultado = new JLabel("Resultado: ---");

        // Botones
        JButton botonGenerar = new JButton("Generar y Ordenar");
        JButton botonSalir = new JButton("Salir");

        // Acción del botón Generar
        botonGenerar.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                try {
                    int cantidad = Integer.parseInt(campoCantidad.getText());

                    // Paso 1: Generar números aleatorios y guardarlos en archivo
                    File archivoEntrada = new File("entrada.txt");
                    try (BufferedWriter bw = new BufferedWriter(new FileWriter(archivoEntrada))) {
                        Random rand = new Random();
                        for (int i = 0; i < cantidad; i++) {
                            int numero = rand.nextInt(1000); // números aleatorios entre 0 y 999
                            bw.write(String.valueOf(numero));
                            bw.newLine();
                        }
                    }

                    // Paso 2: Ejecutar la ordenación externa
                    File archivoSalida = new File("salida.txt");
                    ordenarArchivo(archivoEntrada, archivoSalida);

                    // Paso 3: Mostrar el resultado ordenado en la etiqueta
                    StringBuilder sb = new StringBuilder();
                    try (BufferedReader br = new BufferedReader(new FileReader(archivoSalida))) {
                        String linea;
                        while ((linea = br.readLine()) != null) {
                            sb.append(linea).append(" ");
                        }
                    }
                    etiquetaResultado.setText("Ordenado: " + sb.toString());

                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(ventana, "Error: " + ex.getMessage());
                }
            }
        });

        // Acción del botón salir
        botonSalir.addActionListener(e -> System.exit(0));

        // Agrego los componentes a la ventana
        ventana.add(etiquetaInfo);
        ventana.add(campoCantidad);
        ventana.add(botonGenerar);
        ventana.add(etiquetaResultado);
        ventana.add(botonSalir);

        ventana.setVisible(true);
    }

    // ==================== ORDENACIÓN EXTERNA ====================

    private static final int TAMANO_BLOQUE = 50; 
    // El tamaño del bloque lo defino yo. 
    // Aquí digo: cargo máximo 50 números en memoria para no saturarla.

    // Este método organiza todo el proceso
    public static void ordenarArchivo(File archivoEntrada, File archivoSalida) throws IOException {
        List<File> archivosTemporales = new ArrayList<>();

        // 1. Divido el archivo en bloques pequeños y ordenados
        try (BufferedReader br = new BufferedReader(new FileReader(archivoEntrada))) {
            List<String> buffer = new ArrayList<>();
            String linea;
            while ((linea = br.readLine()) != null) {
                buffer.add(linea);
                if (buffer.size() == TAMANO_BLOQUE) {
                    archivosTemporales.add(guardarBloqueOrdenado(buffer));
                    buffer.clear();
                }
            }
            if (!buffer.isEmpty()) {
                archivosTemporales.add(guardarBloqueOrdenado(buffer));
            }
        }

        // 2. Mezclo los bloques ordenados en el archivo final
        mezclarArchivos(archivosTemporales, archivoSalida);

        // 3. Borro los archivos temporales
        for (File temp : archivosTemporales) {
            temp.delete();
        }
    }

    // Este método guarda un bloque en memoria y lo ordena
    private static File guardarBloqueOrdenado(List<String> bloque) throws IOException {
        Collections.sort(bloque); 
        File temp = File.createTempFile("bloque", ".txt");
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(temp))) {
            for (String linea : bloque) {
                bw.write(linea);
                bw.newLine();
            }
        }
        return temp;
    }

    // Este método mezcla todos los bloques en uno solo ordenado
    private static void mezclarArchivos(List<File> archivos, File archivoSalida) throws IOException {
        PriorityQueue<EntradaArchivo> pq = new PriorityQueue<>(Comparator.comparing(e -> e.linea));
        List<BufferedReader> lectores = new ArrayList<>();

        try (BufferedWriter bw = new BufferedWriter(new FileWriter(archivoSalida))) {
            for (File f : archivos) {
                BufferedReader br = new BufferedReader(new FileReader(f));
                lectores.add(br);
                String linea = br.readLine();
                if (linea != null) {
                    pq.add(new EntradaArchivo(linea, br));
                }
            }

            while (!pq.isEmpty()) {
                EntradaArchivo ea = pq.poll();
                bw.write(ea.linea);
                bw.newLine();
                String nuevaLinea = ea.lector.readLine();
                if (nuevaLinea != null) {
                    pq.add(new EntradaArchivo(nuevaLinea, ea.lector));
                }
            }
        }

        for (BufferedReader br : lectores) {
            br.close();
        }
    }

    private static class EntradaArchivo {
        String linea;
        BufferedReader lector;

        EntradaArchivo(String linea, BufferedReader lector) {
            this.linea = linea;
            this.lector = lector;
        }
    }
}
